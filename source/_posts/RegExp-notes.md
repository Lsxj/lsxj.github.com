---
title: js谜之正则表达式
date: 2016-08-15 22:57:58
categories: 前端开发
tags: [javascript, 正则表达式]
---

## 前言
好久之前就说要写一篇正则表达式的文章，正则表达式总是记了又忘，忘了再记，记了再忘，卒。
言归正传，今天终于要研究一下这个谜一样的正则表达式了。其实正则表达式并不难（真的吗？orz）

## 为什么要用正则表达式
在学习之前，我们需要弄明白，到底什么时候需要用到正则表达式，正则表达式的用途究竟是什么？
比如说，你正在搜索一个文件，这个文件里面包含单词car(不区分大小写)，但是呢你又不想把包含字符串car的其他单词（例如carry）也一起找出来，那么这个时候你就可以使用正则表达式来帮你解决问题。当然，这只是众多场景中的一种。正则表达式功能强大，可以帮你解决各种匹配文本问题。又或者表单验证的方式，也可以使用正则表达式来解决。

## 正则表达式是什么
简单来说，正则表达式就是字符串，是用来匹配和处理文本的字符串。用正则表达式语言创建的。

## 正则表达式的语法
### 匹配字符
* `.`（英文句号）：匹配任何一个单个字符
* `[]`：匹配集合内多个字符中的某个字符
e.g. `[ns]a` --> 匹配 na 或sa
* `[-]`：匹配该区间内的字符
e.g. [a-z] , [0-9]
* `^` 取非匹配：除了该字符集内的字符，都可以匹配。只有当`^`出现在`[`和`]`之间，且紧跟在`[`后面，才能发挥取非的作用。
e.g. `[^0-9]` 匹配非数字的字符

### 使用元字符
元字符：在正则表达式中有特殊含义的字符。若需要表示该字符本身，需使用`\`转义。
* `\d` 任何一个数字字符，相当于[0-9]
* `\D` 任何一个非数字字符，相当于[^0-9]
* `\w` 任何一个字母数字字符或下划线字符，相当于[a-zA-Z0-9_]
* `\W` 任何一个非字母数字字符或非下划线字符，相当于[^a-zA-Z0-9_]
* `\s` 任何一个空白字符，等价于[\f\n\r\t\v]
* `\S` 任何一个非空白字符，等价于[^\f\n\r\t\v]

总而言之，小写字母与大写字母都是相反的，所以记住小写字母的含义，大写字母则是对应的取非含义。

### 重复匹配
* `?` 0个或1个字符
e.g. [0-9]? 出现0次或一次，且最多只能出现1次数字。
* `+` 一个或多个字符
e.g. [0-9]+ 表示一个或多个连续的数字
* `*` 0个或多个字符
e.g. [0-9]* 连续出现0次货多次的数字
* `{n}` 设置一个精确的重复的值
e.g. [0-9]{3} 三个数字
* `{min,max}` 设置重复次数的最小值和最大值
e.g. [0-9]{2,4} 最少2个数字，最多4个数字
* `{min, }` 设置重复次数的最小值
e.g. [0-9]{2,} 最少2个数字

### 懒惰型匹配

为了防止出现重复匹配造成的过度匹配，因为`*`和`+`都是“贪婪型”元字符，它们在进行匹配时会尽可能从一段文本的开头一直匹配到这段文本的末尾，而不是碰到第一个匹配就结束。

那么这个时候就需要使用"懒惰型"。仅需在贪婪型元字符后加上`?`即可。如：`*?`,`+?`,`{n,}?` 


### 位置匹配
* `\b` 单词边界
* `\B` 非单词边界。查找前后都有多余空格的连字符。
* `^` 字符串开头。出现在字符集合的外面且位于一个模式的开头，`^`匹配字符串的开头
* `$` 字符串结尾


---


## Javascript中的正则表达式
ECMAScript通过`RegExp`类型来支持正则表达式。

    var expression = / pattern / flags；
    
其中`pattern`可以是任何简单或复杂的正则表达式。
`flags`用来标明正则表达式的行为。如下所示：
* `g` : 全局模式。模式应用于所有的字符串，不是在发现第一个匹配项后就立即停止的。
* `i` : 不区分大小写。正则表达式默认是区别大小写的。`i`则是忽略大小写
* `m` : 表示多行模式，也就是说到达一行文本末尾的时候还会继续查找下一行中是否存在与模式匹配的项。

### 创建正则表达式的方式
* 以**字面量形式**来定义  
`var pattern = /sxj/i;`

* 使用`RegExp`构造函数    
`var pattern = new RegExp("sxj", "i"); `

那么这两种方式的区别除了形式不一样，还有一个差别在于：
ECMAScript 3中，正则表达式字面量始终会**共享**同一个`RegExp`实例；而使用构造函数创建的每一个实例都是一个**新**实例。

不过！【敲黑板！】ECMAScript 5明确规定了，使用正则表达式字面量必须想直接调用`RegExp`构造函数一样，每次都创建新的RegExp实例。而各大浏览器也对此进行了修改。

### `RegExp`实例
#### 实例属性
* `global`: 布尔值，表示是否设置了`g`标志
* `ignoreCase`: 布尔值，表示是否设置了`i`标志
* `multiline`: 布尔值，表示是否设置了`m`标志
* `lastIndex`：整数，表示开始搜索下一个匹配项的字符位置，从0开始。
* `source`： 正则表达式的字符串表示。按照**字面量形式**返回。

#### 实例方法
##### `exec()`

    pattern.exec(text);

查找text中的匹配项。

    //例子
    var pattern = /sxj/i;
    var text = "sxj is a good student sxj haha";
    console.log(pattern.exec(text));
    //["sxj", index: 0, input: "sxj is a good student sxj haha"]
    var pattern2 = /shi/i;
    console.log(pattern2,exec(text));//null
    
从上述例子可以发现，若找到，则返回一个数组，该数组包含第一个匹配项，除此之外，还有两个属性：`index`（匹配项在字符串中的位置）,`input`（应用正则表达式的字符串）。若没有匹配项返回`null`。

对于`exec`而言，无论是否设置`g`全局标志，每次也只会返回一个匹配项。但是如果在同一个字符串上多次调用，设置了`g`标志则会继续查找新的匹配项，而没有设置的话只会返回第一个匹配项信息。除此之外，pattern的`lastIndex`属性在全局模式会增加，非全局模式始终不变。

##### `test()`
    pattern.test(text);

查看目标字符串与该模式是否匹配。匹配返回true，否则返回false。

### String中的正则表达式
##### `match()`

    text.match(pattern);
    
`match`匹配一个字符串和一个正则表达式。若没有`g`标识，则结果与`pattern.exec(text)`相同。若有`g`标志，则返回一个包含所有匹配的数组。

##### `search()`

    text.search(pattern);
    
若找到匹配，返回第一个匹配的首字符位置。若没有找到返回-1。  
此方法会忽略`g`标识，且没有position参数。

##### `replace()`

    string.replace(searchValue, replaceValue);
    
`searchValue`可以是一个字符串或一个正则表达式对象。若是一个字符串，只会在第一次出现的地方被替换。若是一个正则表达式，若有`g`标志则替换所有匹配之处，若没有则只替换第一个匹配之处。


## 总结
正则表达式是个非常好用的工具，若掌握了可达到事半功倍的效果。好好学哟~